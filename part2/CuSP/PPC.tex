\section{La programmation par contraintes}

Cette section s'intéresse à la présentation des concept de base de la
programmation par contraintes (PPC). La programmation par contraintes
vise à résoudre des problèmes de satisfaction de contraintes (CSP)
mais aussi des problèmes d'optimisation (ce dernier cas ne sera pas
traité dans ce manuscrit). Pour cela, un problème est
modélisé à l'aide d'un réseau de contraintes et la recherche d'une
solution tend à trouver une affectation des variables satisfaisant
toutes les contraintes de ce réseau. Une présentation formelle des
problèmes de satisfaction de contraintes ainsi qu'un aperçu de
quelques méthodes permettant leur résolution est présentée dans les
paragraphes suivants. 

\subsection{Problème de satisfaction de contraintes}

Une instance d'une {\it problème de satisfaction de contraintes}, ou CSP est
la donnée d'un triplet $Q=(\X,\D,\C)$ où: 
\begin{itemize}
\item $\X=\{X_1,X_2,\dots,X_n\}$ est l'ensemble des variables du problème;
\item $\D=\{D_1,D_2,\dots,D_n\}$ est l'ensemble des domaines de ces
  variables, i.e. $X_i \in D_i,\ i=1,\dots,n$;
\item $\C=\{C_1,C_2,\dots,C_m\}$ définit l'ensemble des contraintes du
  problème où chaque $C_j$ définit un sous-ensemble du produit
  cartésien des domaines des variables sur lesquelles elle porte:
  $C_j(X_{j1},X_{j2},\dots,X_{jk}) \subseteq D_{j1} \times D_{j2}
  \times \dots \times D_{jk}$

La notion de domaine désigne l'ensemble des valeurs que peut prendre
une variable. La nature de ces domaines peut potentiellement être très
différente. Par exemple:
\begin{itemize}
\item un intervalle d'entiers;
\item un intervalle de réels;
\item un ensemble d'entiers non contigus: il est possible d'utiliser
  un ensemble d'entiers quelconque, e.g. $D=\{4,9,26\}$;
\item un ensemble de valeurs symboliques: on peut vouloir représenter
  des couleurs, ou encore des jours de la semaine... 
\end{itemize}
Formellement, une contrainte peut être définit comme une relation
définit sur un ensemble de variables. 

Une fois les variable définit, nous pouvons ajouter des contraintes
les liant entre elles. Ici aussi, plusieurs types de contraintes
existent. Nous détaillons trois d'entre elles. 

Le premières contraintes présentées sont les contraintes en {\it
  extension}. Pour ces contraintes, étant donnée un sous-ensemble de
variables, on définit explicitement la liste des tuples
autorisés. Suivant les cas, ces contraintes peuvent aussi être définit
comme une liste de tuples interdits. Le secondes contraintes
détaillées sont les contraintes en {\it intention}. Dans ce cas, les
contraintes sont décrites sous forme d'expression arithmétique
définissant  une relation entre les variables. Enfin, les dernières
contraintes décrites sont les contraintes globales. Ces contraintes
sont des relations prédéfinies, ayant une signification précise. Des
exemple de telles contraintes sont décrit dans
l'exemple~\ref{ex:contrainte}. Notons que si les variables sont à
valeurs dans $\mathbb{R}$ alors une définition en extension de la
contraintes peut comprendre un nombre infini de tuples.

\begin{ex}
  Soient trois variables $x_0,\ x_1$ et $x_2$ de domaine $D_0=[0,2],\
  D_1=[0,2]$ et $D_2=[1,2]$. 
  Nous considérons les contraintes $c_0,\ c_1$ et $c_2$ suivantes:
  \begin{itemize}
  \item $c_0$ est décrite en intention: $x_0 < x_1$;
  \item $c_1$ est décrite en extension: $\{(0,1) , (0,2), (1,2)\}$
  \item $c_2$ est une contrainte  globale portant sur les variable
    $x_0,x_1$ et $x_2$: allDifferent$(x_0,x_1,x_2)$. Cette contrainte
    stipule que les valeurs affectées à chaque variable soient
    différentes les une des autres. 
  \end{itemize}
  Les domaines des variables étant continus, un nombre infini de
tuples aurait été nécessaire pour écrire $c_0$ en extension.
\end{ex}

Pour trouver une solution à un CSP, il faut instancier toutes les
variables du problème de telles sorte que toutes les contraintes
soient satisfaites. Une variable est dite {\it instanciée} quand on
lui assigne une valeur de son domaine. Pour trouver une telle
instanciation, un certain nombres de techniques ont été mises en
place. Ces techniques reposent principalement sur deux éléments
centraux: le filtrage des domaines et l'exploration de l'espace de
recherche. Ces deux concepts sont donc décrits dans les paragraphes
suivants.

\subsection{Exploration de l'espace de recherche}
\label{sec:PPC_rech}

{\'E}tant donné un CSP, différentes techniques d'exploration de
l'espace de recherche peuvent être employées pour trouver des
solutions. Parmi elles, on trouve les techniques de recherche dites
systématiques. Celles-ci consistent à tester successivement toutes les
instanciations possibles des variables, jusqu'à trouver une solution
ou une incohérence remettant en cause la dernière instanciation
effectuée. Dans le second cas, on continue la recherche en supprimant
cette instanciations de l'espace de recherche. Ces combinaisons
peuvent être générées de différentes manière et donc testées dans des
ordres différents. 

Une représentation usuelle du processus de recherche d'une solution
est l'{\it arbre de recherche}. La racine de cette arbre représente le
problème que l'on cherche à résoudre et les sommets sont des problèmes
réduits, obtenus en décomposant le domaine d'une des variables du
problème père. Les feuilles de cet arbre correspondent donc à des
instanciations de toutes les variables du problèmes.

Une première approche alors à générer tous les tuples de valeurs
possibles et de tester s'ils sont solutions du problème, i.e. si cette
instanciation satisfait bien toutes les contraintes du problème.  Cela
revient à considérer toutes les affectations possibles des variables
et ce nombre, qui peut ne pas être fini dans le cas des variables
continues, est égal au produit cartésien du cardinal des domaines des
variables impliquées dans le CSP pour des variables dans
$\mathbb{Z}$.

La seconde méthode, le {\it backtracking}, cherche à étendre
progressivement une solution partielle en instanciant, à chaque
étape, une nouvelle variable à une valeur de son domaine. Si la
nouvelle instanciation partielle ainsi obtenue n'est pas une solution
partielle, on effectue un {\it backtrack} sur $X_i$, i.e. $X_i$ est
instanciée à une autre valeur de son domaine. Dans le cas où le
domaine de $X_i$ ne contient plus de valeurs non testées, alors il y a
deux possibilités: les domaine de toutes les autres variables sont
vides et, dans ce cas, le problème est insatisfiable; sinon, on
effectue un nouveau backtrack sur la dernière variable instanciée du
problème. Le processus se poursuit ainsi jusqu'à ce qu'une solution
complète soit trouvée. 

Dans le cas de CSP comprenant des variables continues, l'énumération
de tous les domaines des variables n'est pas possible. Une première
approche serait de considérer qu'une variable est instanciée quand son
domaine est réduit à un intervalle de taille suffisamment petite. Mais
même avec cette restriction supplémentaire, il est très coûteux
d'énumérer chacun de ces intervalles. L'idée est alors la suivante: au
lieu, à chaque étape de l'algorithme de backtracking, d'instancier une
variable à une valeur de son domaine, nous séparons le domaine de
cette variable en deux (ou plusieurs) sous-domaines.

consiste alors à parcourir l'arbre de recherche
jusqu'à arriver à une feuille et si cette feuille ne correspond pas à
une instanciation valide, alors l'exploration d'autre branche de
l'arbre de recherche est alors nécessaire. Si, au contraire,
l'instanciation des variables correspondant à cette feuille satisfait
toutes les contraintes du problème, alors une solution a été trouvée
et l'algorithme peut s'arrêter. Cependant, en pratique, une telle
méthode ne peut être appliquée. En effet, dans le pire des cas, il
faudrait parcourir tout l'arbre de recherche. Cela revient à
considérer toutes les affectations possibles des variables et ce
nombre, qui peut ne pas être fini dans le cas des variables continues,
est de l'ordre de $O(|\X|^{|\D|})$ pour des variables dans
$\mathbb{Z}$.

Plusieurs techniques de séparation du problème en sous-problème, aussi
appelées techniques de {\it branchement}, existent. Parmi les plus
classiques on trouve:
\begin{itemize}
\item l'affectation d'une valeur du domaine à une variable pour la
  première branche et la suppression de cette valeur du domaine pour
  la seconde branche. L'arbre de recherche est alors un arbre binaire.
\item la séparation du domaine en plusieurs sous-domaine, e.g. si,
dans un problème, une variable $x$ a le domaine $[0,6]$ alors on peut
crée $3$ sous-problèmes où $x$ a pour domaine respectif $[0,2[$,
$[2,4[$ et $[4,6[$. 
\end{itemize}

\begin{ex}
Soient $3$ variables, $x,\ y$ et $z$, de domaine
respectifs: $\{1,2\},\ \{1,2\},\ \{1,2,3\}$. Nous considérons la
contrainte AllDifferent($x,y,z$): chaque variable doit prendre une
valeur différente.   
  \begin{figure}[!htb]
    \centering
    \begin{tikzpicture}
      \node (O) at (0,0) {};    
    \end{tikzpicture}
    \caption{Exemple de parcours d'un arbre de recherche}
    \label{fig:ex_tree}
  \end{figure}
\end{ex}


\subsection{Filtrage et propagation}
\label{sec:PPC_propag}

Pour accélérer le processus de résolution, des techniques de filtrages 

