\section{La programmation par contraintes}

Cette section s'intéresse à la présentation des concept de base de la
programmation par contraintes (PPC). La programmation par contraintes
vise à résoudre des problèmes de satisfaction de contraintes (CSP)
mais aussi des problèmes d'optimisation (ce dernier cas ne sera pas
traité dans ce manuscrit). Pour cela, un problème est
modélisé à l'aide d'un réseau de contraintes et la recherche d'une
solution tend à trouver une affectation des variables satisfaisant
toutes les contraintes de ce réseau. Une présentation formelle des
problèmes de satisfaction de contraintes ainsi qu'un aperçu de
quelques méthodes permettant leur résolution est présentée dans les
paragraphes suivants. 

\subsection{Problème de satisfaction de contraintes}

Une instance d'une {\it problème de satisfaction de contraintes}, ou CSP est
la donnée d'un triplet $Q=(\X,\D,\C)$ où: 
\begin{itemize}
\item $\X=\{X_1,X_2,\dots,X_n\}$ est l'ensemble des variables du problème;
\item $\D=\{D_1,D_2,\dots,D_n\}$ est l'ensemble des domaines de ces
  variables, i.e. $X_i \in D_i,\ i=1,\dots,n$;
\item $\C=\{C_1,C_2,\dots,C_m\}$ définit l'ensemble des contraintes du
  problème où chaque $C_j$ définit un sous-ensemble du produit
  cartésien des domaines des variables sur lesquelles elle porte:
  $C_j(X_{j1},X_{j2},\dots,X_{jk}) \subseteq D_{j1} \times D_{j2}
  \times \dots \times D_{jk}$
\end{itemize}

La notion de domaine désigne l'ensemble des valeurs que peut prendre
une variable. La nature de ces domaines peut potentiellement être très
différente. Par exemple:
\begin{itemize}
\item un intervalle d'entiers;
\item un intervalle de réels;
\item un ensemble d'entiers non contigus: il est possible d'utiliser
  un ensemble d'entiers quelconque, e.g. $D=\{4,9,26\}$;
\item un ensemble de valeurs symboliques: on peut vouloir représenter
  des couleurs, ou encore des jours de la semaine... 
\end{itemize}
Formellement, une contrainte peut être définit comme une relation
définit sur un ensemble de variables. 

Une fois les variable définies, nous pouvons ajouter des contraintes
les liant entre elles. Ici aussi, plusieurs types de contraintes
existent. Nous détaillons trois d'entre elles. 

Les premières contraintes présentées sont les contraintes en {\it
  extension}. Pour ces contraintes, étant donnée un sous-ensemble de
variables, on définit explicitement la liste des tuples
autorisés. Suivant les cas, ces contraintes peuvent aussi être définit
comme une liste de tuples interdits. Le secondes contraintes
détaillées sont les contraintes en {\it intention}. Dans ce cas, les
contraintes sont décrites sous forme d'expression arithmétique
définissant  une relation entre les variables. Enfin, les dernières
contraintes décrites sont les contraintes globales. Ces contraintes
sont des relations prédéfinies, ayant une signification précise. Des
exemple de telles contraintes sont décrit dans
l'exemple~\ref{ex:contrainte}. Notons que si les variables sont à
valeurs dans $\mathbb{R}$ alors une définition en extension de la
contraintes peut comprendre un nombre infini de tuples.

\begin{ex}
\label{ex:contrainte}
  Soient trois variables $x_0,\ x_1$ et $x_2$ de domaine $D_0=[0,2],\
  D_1=[0,2]$ et $D_2=[1,2]$. 
  Nous considérons les contraintes $c_0,\ c_1$ et $c_2$ suivantes:
  \begin{itemize}
  \item $c_0$ porte sur les variable $x_0$ et $x_1$ et est décrite en
    intention: $x_0 \le x_1$; 
  \item $c_1$ porte sur $x_1$ et $x_2$ et est décrite en extension:
    $\{(0,1) , (0,2), (1,2), (2,2)\}$; 
  \item $c_2$ est une contrainte  globale portant sur les variable
    $x_0,x_1$ et $x_2$: allDifferent$(x_0,x_1,x_2)$. Cette contrainte
    stipule que les valeurs affectées à chaque variable soient
    différentes les une des autres. 
  \end{itemize}
  Les domaines des variables étant continus, un nombre infini de
tuples aurait été nécessaire pour écrire $c_0$ en extension.
\end{ex}

Pour trouver une solution à un CSP, il faut instancier toutes les
variables du problème de telles sorte que toutes les contraintes
soient satisfaites. Une variable est dite {\it instanciée} quand on
lui assigne une valeur de son domaine. Pour trouver une telle
instanciation, un certain nombres de techniques ont été mises en
place. Ces techniques reposent principalement sur deux éléments
centraux: le filtrage des domaines et l'exploration de l'espace de
recherche. Ces deux concepts sont donc décrits dans les paragraphes
suivants.



\subsection{Exploration de l'espace de recherche}
\label{sec:PPC_rech}

{\'E}tant donné un CSP, différentes techniques d'exploration de
l'espace de recherche peuvent être employées pour trouver des
solutions. Cette exploration se fait en général par {\it séparation et
  évaluation}, i.e. on sépare le problème difficile à résoudre en deux
sous-problèmes, plus petit, jusqu'à obtenir un problème que l'on sera
capable de résoudre en temps raisonnable.  

Une représentation usuelle du processus de recherche d'une solution
est l'{\it arbre de recherche}. La racine de cette arbre représente le
problème que l'on cherche à résoudre et les sommets sont des problèmes
réduits, obtenus en décomposant le domaine d'une des variables du
problème père. Les feuilles de cet arbre correspondent donc à des
instanciations de toutes les variables du problèmes.

Une première approche consiste alors à générer tous les
tuples de valeurs possibles et de tester s'ils sont solutions du
problème, i.e. si cette instanciation satisfait bien toutes les
contraintes du problème. Cela revient à considérer toutes les
affectations possibles des variables et ce nombre, qui peut ne pas
être fini dans le cas des variables continues, est égal au produit
cartésien du cardinal des domaines des variables impliquées dans le
CSP pour des variables dans $\mathbb{Z}$.

Classiquement, une méthode de séparation, ou de branchement, consiste
à fixer une variable à une valeur pour le premier sous-problème et de
retirer cette valeur du domaine de la variable dans le second
sous-problème. On va alors, à l'aide d'un parcours en profondeur, crée
un premier tuple, i.e. une solution candidate, qui pourra ainsi être
évalué. SI le tuple satisfait toutes les contraintes du problème,
alors c'est une solution et l'algorithme peut s'arrêter. Dans le cas 
contraire, on évaluera le second-sous problème crée lors de la
dernière séparation. Un tel parcours est décrit dans
l'exemple~\ref{ex:brachement}.

Dans le cas de CSP comprenant des variables continues, l'énumération
de tous les domaines des variables n'est pas possible. Une première
approche serait de considérer qu'une variable est instanciée quand son
domaine est réduit à un intervalle de taille suffisamment petite. Mais
même avec cette restriction supplémentaire, il est très coûteux
d'énumérer chacun de ces intervalles. L'idée est alors la suivante: au
lieu, à chaque étape de l'algorithme de séparation, d'instancier une
variable à une valeur de son domaine, nous séparons le domaine de
cette variable en deux (ou plusieurs) sous-domaines.

Plusieurs techniques de séparation du problème en sous-problème, aussi
appelées techniques de {\it branchement}, existent. Parmi les plus
classiques on trouve:
\begin{itemize}
\item l'affectation d'une valeur du domaine à une variable pour la
  première branche et la suppression de cette valeur du domaine pour
  la seconde branche. L'arbre de recherche est alors un arbre binaire.
\item la séparation du domaine en plusieurs sous-domaine, e.g. si,
dans un problème, une variable $x$ a le domaine $[0,6]$ alors on peut
crée $3$ sous-problèmes où $x$ a pour domaine respectif $[0,2[$,
$[2,4[$ et $[4,6[$. 
\end{itemize}

\begin{ex}
Soient $3$ variables, $x,\ y$ et $z$, de domaine
respectifs: $\{1,2\},\ \{1,2\},\ \{1,2,3\}$. Nous considérons la
contrainte AllDifferent($x,y,z$): chaque variable doit prendre une
valeur différente.   
  \begin{figure}[!htb]
    \centering
    \begin{tikzpicture}
      \node (O) at (0,0) {};    
    \end{tikzpicture}
    \caption{Exemple de parcours d'un arbre de recherche}
    \label{fig:ex_tree}
  \end{figure}
\end{ex}

%TODO : heuristique
Ces combinaisons peuvent être générées de différentes manière et donc
testées dans des ordres différents. 



\subsection{Filtrage et propagation}
\label{sec:PPC_propag}

